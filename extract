#!/usr/bin/env python

"""extract

Extraction tool that unarchives archived files found in the
current directory. Extract will look inside each archive
and determine if the archive's contents have their own
top-level directory. If not, one will be created based
on the name of the archive (minus the extension).
"""

import os
import sys
import os.path
import optparse
from zipfile import ZipFile

__version__ = "0.2"
__copyright__ = "CopyRight (C) 2008 by James Mills"
__author__ = "James Mills, prologic at shortcircuit dot net dot au"
__url__ = "http://prologic.shortcircuit.net.au/"

USAGE = "%prog [options] [pattern]"
VERSION = "%prog v" + __version__

def parse_options():
	"""parse_options() -> opts, args

	Parse and command-line options given returning both
	the parsed options and arguments.
	"""

	parser = optparse.OptionParser(usage=USAGE, version=VERSION)

	parser.add_option("-v", "--verbose",
			action="store_true", default=False, dest="verbose",
			help="Verbose output during operation.")

	opts, args = parser.parse_args()

	return opts, args

def getFiles(root, pattern=".*", tests=[isfile], **kwargs):
	"""getFiles(root, pattern=".*", tests=[isfile], f**kwargs) -> list of files

	Return a list of files in the specified path (root)
	applying the predicates listed in tests returning
	only the files that match the pattern. Some optional
	kwargs can be specified:
	 * full=True		(Return full paths)
	 * recursive=True	(Recursive mode)
	"""

	def test(file, tests):
		for test in tests:
			if not test(file):
				return False
		return True

	full = kwargs.get("full", False)
	recursive = kwargs.get("recursive", False)

	files = []

	for file in os.listdir(root):
		path = os.path.abspath(os.path.join(root, file))
		if os.path.isdir(path):
			if recursive:
				files.extend(getFiles(path, pattern, **kwargs))
		elif test(path, tests) and re.match(pattern, path):
			if full:
				files.append(path)
			else:
				files.append(file)

	return files

class Extractor(object):

	def __init__(self, path, files, opts):
		self.path = path
		self.files = files
		self.opts = opts

		self.verbose = opts.verbose or False

	def handleZIP(self, file):
		zipfile = ZipFile(file)
		names = zipfile.namelist()
		commonprefix = os.path.commonprefix(names) or None
		base = os.path.splitext(os.path.basename(file))[0]

		if commonprefix is None:
			path = os.path.join(self.path, base)
			os.mkdir(path)
		else:
			path = ""

		for name in names:
			dirname = os.path.dirname(os.path.join(path, name))
			if not os.path.exists(dirname):
				os.makedirs(dirname)
			outfile = open(os.path.join(path, name), "wb")
			outfile.write(zipfile.read(name))
			outfile.close()

		zipfile.close()

	def __call__(self):
		for file in self.files:
			root, ext = os.path.splitext(file)
			ext = ext.strip(".")
			handler = getattr(self, "handle%s" % ext.upper(), None)
			if handler:
				handler(file)
			else:
				if self.verbose:
					print >> sys.stderr, "No handler for %s files" % ext

def main():
	opts, args = parse_options()

	path = cwd = os.getcwd()
	if args:
		pattern = args[0]
	else:
		pattern = ".*\.zip$"

	files = getFiles(path, pattern, full=True)
	extractor = Extractor(path, files, opts)
	extractor()

if __name__ == "__main__":
	main()
